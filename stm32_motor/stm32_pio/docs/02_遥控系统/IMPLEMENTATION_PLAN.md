# 蓝牙遥控小车实施方案与任务清单

## 📋 硬件连接确认（基于原理图）

### E49-400T20S 无线模块连接
```
E49模块引脚    →    STM32F103RC引脚
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VCC (10)       →    3.3V
GND (1-4,13,14,19-22) → GND
TXD (8)        →    PA10 (USART1_RX)
RXD (7)        →    PA9  (USART1_TX)
M0 (5)         →    PA6  (模式选择0)
M1 (6)         →    PA7  (模式选择1)
AUX (9)        →    PA12 (辅助状态指示)
```

### 遥控器按键映射（ex3.c固件）
```
'F' → 前进    'B' → 后退
'L' → 左转    'R' → 右转
'U' → 加速    'D' → 减速
'W','X','Y','Z' → 功能键
```

---

## 🎯 实施方案

### 阶段1：基础通信验证（先不控制电机）

#### 目标
确保STM32能稳定接收遥控器发送的数据

#### 步骤
1. 配置E49为透传模式（M0=0, M1=0）
2. 配置USART1（9600波特率，8N1）
3. 实现串口接收中断
4. 通过LED闪烁验证收到数据

---

### 阶段2：按键识别与命令映射

#### 目标
正确识别遥控器按键并映射到控制命令

#### 步骤
1. 解析接收到的ASCII字符
2. Switch-case判断按键类型
3. 通过LED不同模式指示不同按键

---

### 阶段3：集成差速转向控制

#### 目标
遥控器控制小车运动

#### 步骤
1. 集成DriveTrain类
2. 按键映射到drive()函数
3. 实现速度档位控制
4. 添加看门狗超时停车

---

### 阶段4：优化与调试

#### 目标
提高控制稳定性和响应速度

#### 步骤
1. 优化中断响应
2. 调整速度参数
3. 添加状态指示
4. 完善错误处理

---

## ✅ 任务清单（按优先级）

### 📌 任务1：GPIO与外设配置

**优先级**：⭐⭐⭐⭐⭐ 最高

**子任务**：
- [ ] 1.1 配置PA6/PA7为输出模式（控制M0/M1）
- [ ] 1.2 配置PA12为输入模式（读取AUX状态）
- [ ] 1.3 配置PA9/PA10为USART1复用功能
- [ ] 1.4 初始化USART1（9600, 8N1）
- [ ] 1.5 使能USART1接收中断

**预期输出**：
- `usart.c` - USART1配置代码
- `e49_control.c` - E49模式控制代码

**验证方法**：
```c
// 测试代码：发送数据回显
uint8_t test[] = "STM32 Ready\r\n";
HAL_UART_Transmit(&huart1, test, sizeof(test), 100);
```

---

### 📌 任务2：E49模块初始化

**优先级**：⭐⭐⭐⭐⭐ 最高

**子任务**：
- [ ] 2.1 设置M0=0, M1=0（透传模式）
- [ ] 2.2 等待AUX变高（模块就绪）
- [ ] 2.3 验证模块工作状态

**预期输出**：
```c
void E49_Init(void);
void E49_SetMode(uint8_t m0, uint8_t m1);
bool E49_IsReady(void);  // 读取AUX状态
```

**验证方法**：
- AUX引脚应为高电平（模块就绪）
- 发送数据应能无线传输

---

### 📌 任务3：串口接收中断处理

**优先级**：⭐⭐⭐⭐⭐ 最高

**子任务**：
- [ ] 3.1 实现HAL_UART_RxCpltCallback回调
- [ ] 3.2 创建接收缓冲区
- [ ] 3.3 启动中断接收
- [ ] 3.4 添加错误处理

**预期输出**：
```c
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart);
```

**验证方法**：
```c
// LED闪烁表示收到数据
if (rxByte == 'F') {
    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
}
```

---

### 📌 任务4：按键命令解析

**优先级**：⭐⭐⭐⭐ 高

**子任务**：
- [ ] 4.1 创建命令处理函数
- [ ] 4.2 实现Switch-case按键判断
- [ ] 4.3 记录最后接收时间（用于看门狗）
- [ ] 4.4 添加调试输出（可选）

**预期输出**：
```c
void processRemoteCommand(uint8_t cmd);
```

**验证方法**：
- 按'F'键 → LED1亮
- 按'B'键 → LED2亮
- 按'L'键 → LED3亮

---

### 📌 任务5：集成DriveTrain控制

**优先级**：⭐⭐⭐⭐ 高

**子任务**：
- [ ] 5.1 包含drive_train.hpp头文件
- [ ] 5.2 创建全局DriveTrain对象指针
- [ ] 5.3 按键映射到drive()调用
- [ ] 5.4 实现速度档位变量

**预期输出**：
```c
case 'F': robot->drive(currentSpeed, 0); break;
case 'B': robot->drive(-currentSpeed, 0); break;
case 'L': robot->drive(0, 60); break;
case 'R': robot->drive(0, -60); break;
```

**验证方法**：
- 按遥控器按键，小车应该对应运动

---

### 📌 任务6：速度控制实现

**优先级**：⭐⭐⭐ 中

**子任务**：
- [ ] 6.1 定义速度档位数组
- [ ] 6.2 实现加速('U')逻辑
- [ ] 6.3 实现减速('D')逻辑
- [ ] 6.4 限制速度范围(20-100)

**预期输出**：
```c
int speedLevels[] = {30, 50, 70, 90};
int currentLevel = 1;  // 默认50%

case 'U': 
    if(currentLevel < 3) currentLevel++;
    break;
case 'D':
    if(currentLevel > 0) currentLevel--;
    break;
```

**验证方法**：
- 多次按'U'，小车速度逐渐增加
- 多次按'D'，小车速度逐渐降低

---

### 📌 任务7：看门狗超时保护

**优先级**：⭐⭐⭐⭐ 高（安全关键）

**子任务**：
- [ ] 7.1 记录最后接收时间戳
- [ ] 7.2 主循环检查超时
- [ ] 7.3 超时自动停车
- [ ] 7.4 设置合理的超时时间（500ms）

**预期输出**：
```c
void remoteWatchdog(void);

// 在main循环中
while(1) {
    remoteWatchdog();
    HAL_Delay(10);
}
```

**验证方法**：
- 正常控制小车后，关闭遥控器
- 500ms后小车应自动停止

---

### 📌 任务8：组合按键支持

**优先级**：⭐⭐ 低（可选）

**子任务**：
- [ ] 8.1 维护按键状态结构体
- [ ] 8.2 更新按键状态而非立即执行
- [ ] 8.3 在主循环中根据状态组合控制

**预期输出**：
```c
struct {
    bool forward, backward, left, right;
} keyState;

// F+L = 前进左转
if(keyState.forward && keyState.left) {
    robot->drive(50, 30);
}
```

**验证方法**：
- 同时按'F'+'L'，小车应该前进同时左转

---

### 📌 任务9：状态指示与调试

**优先级**：⭐⭐ 低（辅助）

**子任务**：
- [ ] 9.1 LED指示通信状态
- [ ] 9.2 LED指示当前速度档位
- [ ] 9.3 添加串口调试输出（可选）
- [ ] 9.4 记录运行统计信息

**预期输出**：
- LED闪烁频率表示接收频率
- LED颜色/数量表示速度档位

---

### 📌 任务10：错误处理与恢复

**优先级**：⭐⭐⭐ 中

**子任务**：
- [ ] 10.1 UART错误检测
- [ ] 10.2 自动重启接收
- [ ] 10.3 异常命令过滤
- [ ] 10.4 电机保护（防止堵转）

**预期输出**：
```c
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
    // 清除错误标志
    // 重新启动接收
}
```

---

## 📂 文件结构规划

```
stm32_pio/
├── include/
│   ├── usart.h              ← USART1配置
│   ├── e49_control.h        ← E49模块控制
│   └── remote_control.h     ← 遥控处理逻辑
├── src/
│   ├── usart.c              ← USART实现
│   ├── e49_control.c        ← E49实现
│   ├── remote_control.cpp   ← 遥控处理实现
│   └── main.cpp             ← 主程序
└── docs/
    └── IMPLEMENTATION_PLAN.md ← 本文档
```

---

## 🧪 测试计划

### 测试1：硬件连接测试
**目标**：验证物理连接正确
```c
// 发送测试字符
HAL_UART_Transmit(&huart1, "TEST", 4, 100);
// 用示波器或另一个串口工具验证
```

### 测试2：E49模式测试
**目标**：验证透传模式工作
```c
// 设置透传模式后，发送应该能无线传输
E49_SetMode(0, 0);
HAL_Delay(100);
// 检查AUX状态
if(E49_IsReady()) {
    // 模块就绪
}
```

### 测试3：串口回环测试
**目标**：验证收发正常
```c
// 收到什么就发回什么
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    HAL_UART_Transmit(&huart1, &rxByte, 1, 10);
    HAL_UART_Receive_IT(&huart1, &rxByte, 1);
}
```

### 测试4：按键识别测试
**目标**：验证命令解析正确
```c
// 每个按键对应不同LED
'F' → LED1, 'B' → LED2, 'L' → LED3, 'R' → LED4
```

### 测试5：电机控制测试
**目标**：验证运动控制
```c
// 逐个测试每个方向
// 前进、后退、左转、右转、组合
```

### 测试6：看门狗测试
**目标**：验证超时保护
```c
// 控制小车运动后关闭遥控器
// 应在500ms内自动停止
```

---

## 📊 进度跟踪

| 任务ID | 任务名称 | 优先级 | 状态 | 负责人 | 完成时间 |
|--------|---------|--------|------|--------|----------|
| 1 | GPIO与外设配置 | ⭐⭐⭐⭐⭐ | 待开始 | - | - |
| 2 | E49模块初始化 | ⭐⭐⭐⭐⭐ | 待开始 | - | - |
| 3 | 串口接收中断 | ⭐⭐⭐⭐⭐ | 待开始 | - | - |
| 4 | 按键命令解析 | ⭐⭐⭐⭐ | 待开始 | - | - |
| 5 | 集成DriveTrain | ⭐⭐⭐⭐ | 待开始 | - | - |
| 6 | 速度控制 | ⭐⭐⭐ | 待开始 | - | - |
| 7 | 看门狗保护 | ⭐⭐⭐⭐ | 待开始 | - | - |
| 8 | 组合按键 | ⭐⭐ | 待开始 | - | - |
| 9 | 状态指示 | ⭐⭐ | 待开始 | - | - |
| 10 | 错误处理 | ⭐⭐⭐ | 待开始 | - | - |

---

## 🎯 里程碑

### 里程碑1：通信建立 ✅
- [ ] 完成任务1-3
- [ ] 能稳定接收遥控器数据
- [ ] LED能根据按键闪烁

### 里程碑2：基础控制 🎮
- [ ] 完成任务4-5
- [ ] 小车能响应遥控器基本命令
- [ ] 前进、后退、左转、右转正常

### 里程碑3：完整功能 🚀
- [ ] 完成任务6-7
- [ ] 速度可调
- [ ] 安全保护完善

### 里程碑4：优化完善 ⭐
- [ ] 完成任务8-10
- [ ] 用户体验优化
- [ ] 稳定性提升

---

## 🚀 下一步行动

1. **立即开始**：任务1（GPIO配置）
2. **准备工具**：
   - Keil/PlatformIO编译环境
   - ST-Link调试器
   - 串口调试助手
   - 遥控器和接收模块

3. **编码顺序**：
   - 先写`usart.c`和`e49_control.c`
   - 再写`remote_control.cpp`
   - 最后修改`main.cpp`集成

准备好了吗？我可以开始写代码了！
