C51 COMPILER V9.59.0.0   EX3                                                               07/18/2022 22:22:54 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE EX3
OBJECT MODULE PLACED IN ex3.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ex3.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include<reg51.h>  //包含51单片机寄存器定义的头文件
   2          #include "intrins.h"
   3          #define uint unsigned int 
   4          #define uchar unsigned char 
   5          
   6          #define true  1 
   7          #define false 0 
   8            
   9          sbit  WX_M0=P1^2;
  10          sbit  WX_M1=P1^1;
  11          
  12          sbit trig=P2^0;//触发端口
  13          sbit echo=P3^3;//信号接收端口
  14          sbit tes = P1^0;//测试端口
  15          sbit zhou_1 = P0^0;//舵机控制端口
  16          sbit zhou_2 = P0^1;//舵机控制端口
  17          sbit zhou_3 = P0^2;//舵机控制端口
  18          sbit zhou_4 = P0^3;//舵机控制端口
  19          sbit zhou_5 = P0^4;//舵机控制端口
  20          sbit zhou_6 = P0^5;//舵机控制端口
  21          sbit zhou_7 = P0^6;//舵机控制端口
  22          sbit zhou_8 = P0^7;//舵机控制端口
  23          
  24          //减速电机
  25          sbit MOTO1_A = P2^0;//舵机控制端口
  26          sbit MOTO1_B = P2^1;//舵机控制端口
  27          sbit MOTO2_A = P2^2;//舵机控制端口
  28          sbit MOTO2_B = P2^3;//舵机控制端口
  29          sbit MOTO3_A = P2^4;//舵机控制端口
  30          sbit MOTO3_B = P2^5;//舵机控制端口
  31          sbit MOTO4_A = P2^6;//舵机控制端口
  32          sbit MOTO4_B = P2^7;//舵机控制端口
  33          
  34          uchar FX_MOTO1_A=0;
  35          uchar FX_MOTO1_B=0;
  36          uchar FX_MOTO2_A=0;
  37          uchar FX_MOTO2_B=0;
  38          uchar FX_MOTO3_A=0;
  39          uchar FX_MOTO3_B=0;
  40          uchar FX_MOTO4_A=0;
  41          uchar FX_MOTO4_B=0;
  42          
  43          uchar flag=0;
  44          uchar RX_DATA=0;
  45          
  46          
  47          uint M_t_long=0;
  48          uint t_long1=0;
  49          uchar time_h,time_l;//时间值
  50          uchar distance_h,distance_l;//距离值
  51          uint time,distance;//时间总值，距离总值
  52          uint d;
  53          uchar d0,d1,d2,d3;
  54          void delay_nus(unsigned int i);
  55          //串口初始化
C51 COMPILER V9.59.0.0   EX3                                                               07/18/2022 22:22:54 PAGE 2   

  56          void init_9600(void)
  57          {
  58   1            SCON= 0x40;              //串口方式1
  59   1          PCON=0;                  //SMOD=0
  60   1          REN=1;                   //允许接收
  61   1          TMOD= 0x20;              //定时器1定时方式2
  62   1          TH1= 0xfd;               //11.0592M 9600波特率
  63   1          TL1= 0xfd;
  64   1          IE |= 0x90 ;             //Enable Serial Interrupt
  65   1          TR1= 1;                  //启动定时器
  66   1      }
  67          //发送一个字节
  68          void send_char(unsigned char txd)
  69          {
  70   1          SBUF = txd;
  71   1          while(!TI);     
  72   1          TI = 0;         
  73   1      }
  74          void send_one_byte_to_char(unsigned char ch)
  75          {
  76   1        if ((ch & 0xf0) > 0x90)
  77   1        {
  78   2          send_char(((ch>>4)&0x0f) + 'A'-0x0a);
  79   2        }
  80   1        else
  81   1        {
  82   2          send_char(((ch>>4)&0x0f) + '0'-0x00);
  83   2        }
  84   1        if ((ch & 0x0f) > 0x09)
  85   1        {
  86   2          send_char((ch&0x0f) + 'A'-0x0a);
  87   2        }
  88   1        else
  89   1        {
  90   2          send_char((ch&0x0f) + '0'-0x00);
  91   2        }
  92   1      }
  93          void send_two_byte_to_char(unsigned int ch)
  94          {
  95   1        //3
  96   1        if ((ch & 0xf000) > 0x9000)
  97   1        {
  98   2          send_char(((ch>>12)&0x000f) + 'A'-0x0a);
  99   2        }
 100   1        else
 101   1        {
 102   2          send_char(((ch>>12)&0x000f) + '0'-0x00);
 103   2        }
 104   1        //2
 105   1        if ((ch & 0x0f00) > 0x0900)
 106   1        {
 107   2          send_char(((ch>>8)&0x000f) + 'A'-0x0a);
 108   2        }
 109   1        else
 110   1        {
 111   2          send_char(((ch>>8)&0x000f) + '0'-0x00);
 112   2        }
 113   1        //1
 114   1        if ((ch & 0x00f0) > 0x0090)
 115   1        {
 116   2          send_char(((ch>>4)&0x000f) + 'A'-0x0a);
 117   2        }
C51 COMPILER V9.59.0.0   EX3                                                               07/18/2022 22:22:54 PAGE 3   

 118   1        else
 119   1        {
 120   2          send_char(((ch>>4)&0x000f) + '0'-0x00);
 121   2        }
 122   1        //0
 123   1        if ((ch & 0x000f) > 0x0009)
 124   1        {
 125   2          send_char((ch&0x000f) + 'A'-0x0a);
 126   2        }
 127   1        else
 128   1        {
 129   2          send_char((ch&0x000f) + '0'-0x00);
 130   2        }
 131   1      }
 132          void send_four_byte_to_char(uchar a,uchar b,uchar c,uchar d)
 133          {
 134   1          send_char(a+'0'-0x00);
 135   1          send_char(b+'0'-0x00);
 136   1          send_char(c+'0'-0x00);
 137   1          send_char(d+'0'-0x00);
 138   1      }
 139          void send_string(char *p)
 140          {
 141   1        char *pchar;
 142   1      
 143   1        pchar = p;
 144   1        while (*pchar != '\0')
 145   1        {
 146   2          send_char(*pchar++);    
 147   2        }
 148   1      }
 149          //定时器0初始化
 150          void T0_INIT(void)
 151          {
 152   1          TMOD &= 0xF0; /* Timer 0 mode 1 with software gate */ 
 153   1          TMOD |= 0x01; /* GATE0=0; C/T0#=0; M10=0; M00=1; */ 
 154   1          TH0 = 0xb8; /* init values */ 
 155   1          TL0 = 0x00; 
 156   1          ET0=1; /* enable timer0 interrupt */ 
 157   1          //EA=1; /* enable interrupts */ 
 158   1          TR0=1; /* timer0 run */
 159   1      }
 160          //定时器1初始化
 161          void T1_INIT(void)
 162          {
 163   1          TMOD &= 0x0F; /* Timer 0 mode 1 with software gate */ 
 164   1          TMOD |= 0x10; /* GATE0=0; C/T0#=0; M10=0; M00=1; */ 
 165   1          TH1 = 0xFC; /* init values */ 
 166   1          TL1 = 0x66; 
 167   1          ET1=1; /* enable timer0 interrupt */ 
 168   1          //EA=1; /* enable interrupts */ 
 169   1          TR1=1; /* timer0 run */
 170   1      }
 171          //外部中断1初始化
 172          void INT1_INIT(void)
 173          {
 174   1        
 175   1        IT1=1;//负跳变中断产生
 176   1        EX1=1;//启动外部1中断
 177   1        //EA=1;
 178   1      }
 179           void delay_100us(unsigned int n)  //n=11
C51 COMPILER V9.59.0.0   EX3                                                               07/18/2022 22:22:54 PAGE 4   

 180          { 
 181   1       while(--n);   
 182   1      }   
 183          
 184          void delay_nus(unsigned int m)  //m*100us
 185          { 
 186   1        
 187   1        while(--m)
 188   1        {
 189   2          delay_100us(11);  
 190   2        }   
 191   1              
 192   1      }   
 193          //延时函数1毫秒
 194          void delay1ms()
 195          {
 196   1         unsigned char i,j; 
 197   1         for(i=0;i<3;i++)
 198   1          for(j=0;j<29;j++)
 199   1           ;     
 200   1       }
 201          
 202          //延时函数，n毫秒
 203           void delaynms(unsigned int n)
 204           {
 205   1         unsigned int i;
 206   1        for(i=0;i<n;i++)
 207   1           delay1ms();
 208   1       }
 209          
 210          //主函数
 211          void main(void)
 212          {
 213   1          uint a,b,c,x,y;
 214   1          uchar d;
 215   1          EA = 0;
 216   1          init_9600();
 217   1          
 218   1        
 219   1          WX_M0=0;//传输模式
 220   1          WX_M1=0;
 221   1          EA = 1;
 222   1          delaynms(10);
 223   1          send_string("ceshi jieshou!");
 224   1          while(1)
 225   1          {   
 226   2              if(flag==1)
 227   2              {
 228   3                  flag=0;
 229   3                  send_char(RX_DATA);
 230   3                EA = 1;
 231   3                  //send_char(0x88);
 232   3              }
 233   2          //delaynms(10);
 234   2          }
 235   1          
 236   1          
 237   1      }
*** WARNING C280 IN LINE 213 OF ex3.c: 'a': unreferenced local variable
*** WARNING C280 IN LINE 213 OF ex3.c: 'b': unreferenced local variable
*** WARNING C280 IN LINE 213 OF ex3.c: 'c': unreferenced local variable
*** WARNING C280 IN LINE 213 OF ex3.c: 'x': unreferenced local variable
C51 COMPILER V9.59.0.0   EX3                                                               07/18/2022 22:22:54 PAGE 5   

*** WARNING C280 IN LINE 213 OF ex3.c: 'y': unreferenced local variable
*** WARNING C280 IN LINE 214 OF ex3.c: 'd': unreferenced local variable
 238          
 239          //串口接收中断函数
 240          void serial () interrupt 4 using 3
 241          {
 242   1          if (RI) //开始接收
 243   1          {
 244   2              EA = 0;
 245   2            flag=1;
 246   2              RI = 0 ; //软件RI=0
 247   2              RX_DATA=SBUF;
 248   2              
 249   2          }
 250   1          
 251   1      } 
 252          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    459    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     28      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  6 WARNING(S),  0 ERROR(S)
