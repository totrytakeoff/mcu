# MDA12E11-830 信号规范修复说明

## 🔴 根本原因找到了！

### 问题根源
**MDA12E11-830 的脉宽规范与标准舵机/ESC 完全不同！**

---

## 信号规范对比

### 标准舵机/ESC（Arduino 默认，之前的代码）
```
1000µs  →  反转最大/最小值
1500µs  →  中位/停止
2000µs  →  正转最大/最大值
```

### MDA12E11-830 实际规范（来自产品手册）⭐
```
Tsig < 1250µs   →  反转最大速
1250~1750µs     →  停止/死区
Tsig > 1750µs   →  正转最大速
```

**关键差异**：
1. 死区范围更宽：1250~1750µs（500µs 死区）
2. 反转阈值：< 1250µs（不是 < 1500µs）
3. 正转阈值：> 1750µs（不是 > 1500µs）

---

## 修复后的脉宽映射

### 百分比到脉宽的转换逻辑

```c
// MDA12E11-830 专用脉宽映射
static inline uint16_t esc_pulse_from_percent(int8_t percent)
{
	if (percent > 100) percent = 100;
	if (percent < -100) percent = -100;
	
	if (percent == 0) {
		return 1500;  // 停止（死区中点）
	} else if (percent > 0) {
		// 正转: 1% → 1750us, 100% → 2200us
		return (uint16_t)(1750 + percent * 4.5);
	} else {
		// 反转: -100% → 800us, -1% → 1250us
		return (uint16_t)(1250 + percent * 4.5);
	}
}
```

### 脉宽范围表

| 百分比 | 脉宽(µs) | 状态 |
|--------|---------|------|
| -100% | 800 | 反转最大速 |
| -50% | 1025 | 反转中速 |
| -1% | 1245 | 反转最小（接近死区） |
| 0% | 1500 | 停止（死区中点） |
| +1% | 1755 | 正转最小（接近死区） |
| +50% | 1975 | 正转中速 |
| +100% | 2200 | 正转最大速 |

---

## 为什么 Arduino 能工作？

### 可能的原因
1. **Arduino 代码使用的脉宽恰好在有效范围内**：
   - `2000µs` > 1750µs → 触发正转
   - `1000µs` < 1250µs → 触发反转
   - `1500µs` 在死区内 → 停止

2. **但速度控制不精确**：
   - Arduino 的 1500→2000µs 只用了正转范围的一半
   - Arduino 的 1000→1500µs 只用了反转范围的一半

### 修复后的优势
- 完整利用 MDA12E11-830 的速度范围
- 死区明确定义（1250~1750µs）
- 百分比映射线性且符合规范

---

## 信号时序要求（已满足）

| 参数 | 要求 | 当前实现 |
|------|------|---------|
| 脉冲极性 | 低电平有效 | ✅ 低电平 |
| Tsig（脉宽） | 根据速度/方向 | ✅ 800~2200µs |
| 周期 | ≥ 20ms | ✅ 20ms (50Hz) |
| 默认电平 | 高 | ✅ 3.3V |

---

## 测试建议

### 测试序列（按顺序）
1. **上电解锁**（已实现）：
   - 发送 1500µs（死区中点）持续 2秒
   - 观察电机是否有初始化声音/LED

2. **测试正转**：
   ```c
   MOTO1_run_for_frames(50, 100);  // 50% 正转，持续 2秒
   ```
   - 预期：电机正转，中等速度

3. **测试停止**：
   ```c
   MOTO1_run_for_frames(0, 50);    // 停止 1秒
   ```
   - 预期：电机停止

4. **测试反转**：
   ```c
   MOTO1_run_for_frames(-50, 100); // 50% 反转，持续 2秒
   ```
   - 预期：电机反转，中等速度

5. **测试极限**：
   - `+100%` → 全速正转
   - `-100%` → 全速反转

---

## 如果仍然不工作

### 可能的其他问题
1. **延时精度**：
   - 虽然已用 SysTick，但 `delay_us()` 可能仍有偏差
   - **解决**：用示波器测量实际脉宽，微调 `SysTick_Config(72)` 的值

2. **GPIO 输出问题**：
   - PC6 可能不是真正连到电机的引脚
   - **解决**：查看 RCB6406/6412 原理图，确认 DO1 对应的引脚

3. **电平不足**：
   - STM32 输出 3.3V，某些驱动板可能需要 5V
   - **解决**：加电平转换电路或用推挽+上拉

4. **板载使能信号**：
   - 可能需要先使能某个控制芯片
   - **解决**：查看 RCB6406/6412 手册，确认是否有 EN 引脚

---

## 调试步骤（如果还不工作）

### 1. 用示波器测量 PC6 波形
确认：
- [ ] 默认电平约 3.3V
- [ ] 有周期性低电平脉冲
- [ ] 脉宽在 800~2200µs 范围
- [ ] 周期约 20ms

### 2. 用万用表测量平均电压
| 百分比 | 预期平均电压 |
|--------|-------------|
| 0% (1500µs) | ~3.05V (92.5% 占空比) |
| 100% (2200µs) | ~2.97V (89% 占空比) |
| -100% (800µs) | ~3.17V (96% 占空比) |

### 3. 检查硬件连接
```
STM32 PC6  →  RCB6406 DO1  →  MDA12E11 SIG
STM32 GND  →  RCB6406 GND  →  MDA12E11 GND  ← 必须！
MDA12E11 12V  ←  外部电源
```

### 4. 查看 RCB6406/6412 原理图
确认：
- DO1~DO8 的实际引脚连接
- 是否有反相器/驱动芯片
- 是否需要使能某个控制信号

---

## 成功后的下一步

1. **扩展到 8 路**：
   - 复制 `MOTO1_run_for_frames` 为 `MOTO2~MOTO8`
   - 在一帧内串行发送所有通道脉冲

2. **优化为硬件 PWM**：
   - 使用 TIM2/TIM3 的多通道 PWM
   - 消除软件延时的不稳定性

3. **添加速度平滑**：
   - 加减速曲线
   - 防止突变损坏电机

---

## 总结

**问题根源**：MDA12E11-830 使用非标准的脉宽规范，与常见舵机/ESC 不同。

**关键修复**：
1. 死区：1250~1750µs（不是 1400~1600µs）
2. 正转：> 1750µs（不是 > 1500µs）
3. 反转：< 1250µs（不是 < 1500µs）

**当前状态**：✅ 编译通过，脉宽映射已修正，请重新烧录测试！
