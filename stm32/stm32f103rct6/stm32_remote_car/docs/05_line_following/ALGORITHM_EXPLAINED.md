# 🧠 巡线算法详解 - 完整原理与实现

## 📚 目录

1. [总体架构](#总体架构)
2. [数据采集层](#数据采集层)
3. [数据处理层](#数据处理层)
4. [控制算法层](#控制算法层)
5. [特殊情况处理](#特殊情况处理)
6. [完整流程图](#完整流程图)

---

## 🏗️ 总体架构

### 三层架构设计

```
┌─────────────────────────────────────────────────────────┐
│                  应用层 (Application)                    │
│  - 用户控制（启动/停止/参数设置）                        │
│  - 状态监控                                              │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│              控制算法层 (LineFollower)                   │
│  - PID 控制算法                                          │
│  - 丢线搜索逻辑                                          │
│  - 十字路口检测                                          │
│  - 速度控制                                              │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│              数据处理层 (LineSensor)                     │
│  - ADC值读取                                             │
│  - 黑白判断                                              │
│  - 位置计算（加权平均）                                  │
│  - 状态检测（在线/丢线/十字路口）                        │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│              数据采集层 (ADC + DMA)                      │
│  - 8通道ADC采样                                          │
│  - DMA自动传输                                           │
│  - 硬件触发                                              │
└─────────────────────────────────────────────────────────┘
```

---

## 📡 数据采集层

### 1. 硬件采样原理

#### 传感器工作原理

```
红外LED发射 → 地面反射 → 光敏三极管接收
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

白色地面（高反射率）:
  LED发光 → 白色地面强反射 → 光敏管导通 → 低电压 → ADC值低（~300-800）

黑色线条（低反射率）:
  LED发光 → 黑色表面弱反射 → 光敏管截止 → 高电压 → ADC值高（~3500-4000）
```

#### 电路模型

```
VCC (3.3V)
  │
  ├─[10kΩ 上拉]─┬─ SIG_OUT ──> ADC通道
  │             │
  │      [光敏三极管]
  │             │
 GND           GND

白色: 光敏管导通 → SIG被拉低 → 0.3V
黑色: 光敏管截止 → SIG保持高 → 3.0V
```

### 2. ADC采样配置

```c
// 8通道扫描模式 + DMA自动传输
ADC配置:
  - 分辨率: 12位 (0-4095)
  - 采样时间: 55.5 cycles
  - 转换时间: 约 5.67μs/通道
  - 8通道总时间: ~45μs
  - 最大采样率: 22kHz
  
DMA配置:
  - 循环模式: 连续采样
  - 自动传输到内存数组
  - 无需CPU干预
```

### 3. 数据存储

```c
uint16_t rawValues[8];  // 存储8个传感器的ADC值

// 自动映射（由DMA完成）:
rawValues[0] ← ADC_CH8  (PB0/SIG1) - 最左侧
rawValues[1] ← ADC_CH9  (PB1/SIG2) - 左2
rawValues[2] ← ADC_CH10 (PC0/SIG3) - 左3
rawValues[3] ← ADC_CH11 (PC1/SIG4) - 中左
rawValues[4] ← ADC_CH12 (PC2/SIG5) - 中右
rawValues[5] ← ADC_CH13 (PC3/SIG6) - 右3
rawValues[6] ← ADC_CH14 (PC4/SIG7) - 右2
rawValues[7] ← ADC_CH15 (PC5/SIG8) - 最右侧
```

---

## 🔄 数据处理层

### 1. 黑白数字化

#### 阈值判断法

```c
#define THRESHOLD 2000  // 默认阈值（约1.65V）

// 对每个传感器进行二值化
bool isBlack(uint8_t index) {
    return rawValues[index] > THRESHOLD;
}
```

#### 典型场景

```
场景1: 小车在线上（正常）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
传感器:  [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
ADC值:   350  380  3800 3850 3820 370  360  340
黑白:    白   白   黑   黑   黑   白   白   白
位图:    0    0    1    1    1    0    0    0  = 0b00011100
结论:    中间3个传感器检测到黑线 ✅


场景2: 小车偏左
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
传感器:  [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
ADC值:   3850 3800 370  360  350  340  330  320
黑白:    黑   黑   白   白   白   白   白   白
位图:    1    1    0    0    0    0    0    0  = 0b00000011
结论:    左侧传感器检测到黑线，需要右转 ➡️


场景3: 丢线
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
传感器:  [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]
ADC值:   340  350  360  370  380  350  340  330
黑白:    白   白   白   白   白   白   白   白
位图:    0    0    0    0    0    0    0    0  = 0b00000000
结论:    完全丢线 ⚠️
```

### 2. 位置计算（核心算法）

#### 加权平均法

**原理**：每个传感器赋予一个位置权重，根据检测到黑线的传感器计算加权平均值。

```c
// 位置权重数组（左负右正）
const int16_t POSITION_WEIGHTS[8] = {
    -1000,  // [0] 最左侧  - 偏左1000
    -700,   // [1] 左2     - 偏左700
    -400,   // [2] 左3     - 偏左400
    -150,   // [3] 中左    - 偏左150
    +150,   // [4] 中右    - 偏右150
    +400,   // [5] 右3     - 偏右400
    +700,   // [6] 右2     - 偏右700
    +1000   // [7] 最右侧  - 偏右1000
};
```

#### 计算公式

```
position = Σ(权重 × 检测到黑线) / Σ(检测到黑线的数量)

例子:
传感器状态: [白, 白, 黑, 黑, 黑, 白, 白, 白]
            [0]  [1]  [2] [3] [4] [5]  [6]  [7]
            
黑线传感器: [2], [3], [4]
权重:       -400, -150, +150

position = (-400 + (-150) + 150) / 3
         = -400 / 3
         = -133
         
结论: 线在中心偏左133单位 → 需要向右转修正
```

#### 实际代码

```cpp
int16_t LineSensor::getPosition() const
{
    int32_t weightSum = 0;   // 权重总和
    int32_t sensorSum = 0;   // 检测到黑线的传感器数量
    
    // 遍历所有传感器
    for (uint8_t i = 0; i < 8; i++) {
        if (isBlack(i)) {  // 如果检测到黑线
            weightSum += POSITION_WEIGHTS[i];  // 累加权重
            sensorSum++;                       // 计数
        }
    }
    
    // 没检测到线 → 返回特殊值
    if (sensorSum == 0) {
        return INT16_MIN;  // -32768
    }
    
    // 返回加权平均位置
    return (int16_t)(weightSum / sensorSum);
}
```

#### 位置值含义

```
position 范围: -1000 ~ +1000

-1000 ←──────── 0 ────────→ +1000
 极左           中心          极右

position = -1000  : 线在最左侧，需要大幅右转
position = -500   : 线在左侧，需要右转
position = 0      : 线在中心，直行 ✅
position = +500   : 线在右侧，需要左转
position = +1000  : 线在最右侧，需要大幅左转
position = INT16_MIN : 未检测到线（丢线）
```

### 3. 状态检测

#### 在线检测

```cpp
bool LineSensor::isOnLine() const
{
    // 只要有任意一个传感器检测到黑线
    for (uint8_t i = 0; i < 8; i++) {
        if (isBlack(i)) {
            return true;  // 在线上
        }
    }
    return false;  // 丢线
}
```

#### 十字路口检测

```cpp
bool LineSensor::isCrossroad() const
{
    // 统计检测到黑线的传感器数量
    uint8_t blackCount = 0;
    for (uint8_t i = 0; i < 8; i++) {
        if (isBlack(i)) {
            blackCount++;
        }
    }
    
    // 至少6个传感器检测到黑线 → 十字路口
    return blackCount >= 6;
}
```

#### 状态判断逻辑

```
状态判断流程:
┌─────────────────────────┐
│ 读取8个传感器ADC值       │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────┐
│ 统计检测到黑线的数量     │
└────────┬────────────────┘
         │
         ├─ blackCount >= 6  → 十字路口 🚦
         ├─ blackCount >= 1  → 在线上 ✅
         └─ blackCount == 0  → 丢线 ⚠️
```

---

## 🎛️ 控制算法层

### 1. PID 控制器

#### PID 基本原理

**PID = 比例(P) + 积分(I) + 微分(D)**

```
输出 = Kp × 误差 + Ki × 误差累积 + Kd × 误差变化率

其中:
- 误差 = position（期望位置为0）
- 误差累积 = integral（积分项）
- 误差变化率 = error - lastError（微分项）
```

#### 各项作用

| 项 | 作用 | 效果 | 问题 |
|----|------|------|------|
| **P（比例）** | 根据当前偏差调整 | 偏差越大，修正越强 | 可能震荡 |
| **I（积分）** | 消除稳态误差 | 累积小偏差并修正 | 可能过冲 |
| **D（微分）** | 预测趋势，抑制震荡 | 平滑控制过程 | 对噪声敏感 |

#### 代码实现

```cpp
float LineFollower::calculatePID(int16_t error)
{
    // ========== P: 比例项 ==========
    float p = kp_ * error;
    // 偏差越大，输出越大
    
    // ========== I: 积分项 ==========
    integral_ += error;  // 累积误差
    
    // 防止积分饱和
    if (integral_ > 10000.0f) integral_ = 10000.0f;
    if (integral_ < -10000.0f) integral_ = -10000.0f;
    
    float i = ki_ * integral_;
    
    // ========== D: 微分项 ==========
    float derivative = error - lastError_;  // 误差变化率
    float d = kd_ * derivative;
    
    // ========== 总输出 ==========
    return p + i + d;
}
```

#### 实例演示

```
假设: Kp=0.1, Ki=0.0, Kd=1.0

时刻1: 线在右侧
  position = +500
  error = +500
  lastError = 0
  
  P = 0.1 × 500 = 50
  I = 0
  D = 1.0 × (500 - 0) = 500
  
  output = 50 + 0 + 500 = 550 (限制到100)
  
  → 大幅左转修正

时刻2: 修正后，线接近中心
  position = +100
  error = +100
  lastError = +500
  
  P = 0.1 × 100 = 10
  I = 0
  D = 1.0 × (100 - 500) = -400
  
  output = 10 + 0 + (-400) = -390
  
  → D项抑制过度修正，防止震荡 ✅
```

### 2. 速度控制

#### 差速转向原理

```
        左轮         右轮
         │           │
         ▼           ▼
    ┌────────┬────────┐
    │        │        │
    │   🚗   │   🚗   │  小车
    │        │        │
    └────────┴────────┘

直行: 左轮速度 = 右轮速度
左转: 左轮慢 < 右轮快
右转: 左轮快 > 右轮慢
```

#### 速度计算

```cpp
// 基础速度
int baseSpeed = 50;  // 0-100%

// PID输出（-100 ~ +100）
float output = calculatePID(error);

// 计算左右轮速度
int leftSpeed  = baseSpeed - output;
int rightSpeed = baseSpeed + output;

/*
例子1: output = +50 (线在右侧，需要左转)
  leftSpeed  = 50 - 50 = 0   (左轮减速/停止)
  rightSpeed = 50 + 50 = 100 (右轮加速)
  结果: 小车左转 ↶

例子2: output = -30 (线在左侧，需要右转)
  leftSpeed  = 50 - (-30) = 80  (左轮加速)
  rightSpeed = 50 + (-30) = 20  (右轮减速)
  结果: 小车右转 ↷

例子3: output = 0 (线在中心)
  leftSpeed  = 50 - 0 = 50
  rightSpeed = 50 + 0 = 50
  结果: 小车直行 ↑
*/
```

### 3. 主控制循环

```cpp
void LineFollower::update()
{
    if (!running_) return;
    
    // ========== 步骤1: 读取传感器 ==========
    sensor_.update();  // DMA读取8路ADC值
    
    // ========== 步骤2: 检查十字路口 ==========
    if (sensor_.isCrossroad()) {
        handleCrossroad();  // 执行十字路口逻辑
        return;
    }
    
    // ========== 步骤3: 获取线条位置 ==========
    int16_t position = sensor_.getPosition();
    
    // ========== 步骤4: 检查是否丢线 ==========
    if (position == INT16_MIN) {
        handleLostLine();  // 执行丢线搜索
        return;
    }
    
    // ========== 步骤5: 记录有效位置 ==========
    lastPosition_ = position;
    lostLineTime_ = 0;
    
    // ========== 步骤6: 计算偏差 ==========
    error_ = position;  // 期望位置为0
    
    // ========== 步骤7: PID 计算 ==========
    output_ = calculatePID(error_);
    
    // ========== 步骤8: 限制输出 ==========
    if (output_ > 100.0f)  output_ = 100.0f;
    if (output_ < -100.0f) output_ = -100.0f;
    
    // ========== 步骤9: 差速控制 ==========
    int leftSpeed  = baseSpeed_ - (int)output_;
    int rightSpeed = baseSpeed_ + (int)output_;
    
    // ========== 步骤10: 控制电机 ==========
    driveTrain_.drive(leftSpeed, rightSpeed);
    
    // ========== 步骤11: 更新历史数据 ==========
    lastError_ = error_;
}
```

---

## 🚨 特殊情况处理

### 1. 丢线处理

#### 检测逻辑

```cpp
// 判断丢线
if (position == INT16_MIN) {
    // 所有传感器都检测到白色
    handleLostLine();
}
```

#### 搜索策略

```cpp
void LineFollower::handleLostLine()
{
    // 记录丢线时间
    if (lostLineTime_ == 0) {
        lostLineTime_ = HAL_GetTick();
    }
    
    uint32_t lostDuration = HAL_GetTick() - lostLineTime_;
    
    if (lostDuration < 500) {
        // ========== 短时间丢线: 智能搜索 ==========
        if (lastPosition_ < 0) {
            // 上次线在左侧 → 向左转搜索
            driveTrain_.drive(-baseSpeed_/2, baseSpeed_/2);
        } else {
            // 上次线在右侧 → 向右转搜索
            driveTrain_.drive(baseSpeed_/2, -baseSpeed_/2);
        }
    } else {
        // ========== 长时间丢线: 停车 ==========
        stop();
    }
}
```

#### 搜索示意图

```
场景: 小车在急弯处丢线

上次位置: lastPosition = -800 (线在左侧)

丢线后:
  ┌─────────────────────────────┐
  │ 向左转搜索                   │
  │ 左轮: -25% (后退)            │
  │ 右轮: +25% (前进)            │
  └─────────────────────────────┘
         │
         ▼
  小车原地左转 ↶
         │
         ▼
  重新找到线条 ✅
```

### 2. 十字路口处理

#### 检测条件

```cpp
bool isCrossroad() {
    // 至少6个传感器检测到黑线
    return blackCount >= 6;
}
```

#### 处理策略

```cpp
void LineFollower::handleCrossroad()
{
    if (crossroadCallback_ != nullptr) {
        // 调用用户自定义回调函数
        bool continueFollowing = crossroadCallback_();
        
        if (!continueFollowing) {
            stop();  // 用户选择停车
        }
    } else {
        // 默认: 直行穿过
        driveTrain_.drive(baseSpeed_, baseSpeed_);
    }
}
```

#### 应用示例

```cpp
// 示例1: 直行穿过十字路口
bool CrossroadHandler() {
    driveTrain.drive(40, 40);  // 直行
    HAL_Delay(300);             // 穿过十字路口
    return true;                // 继续巡线
}

// 示例2: 十字路口左转
bool CrossroadHandler() {
    driveTrain.drive(-40, 40);  // 左转
    HAL_Delay(500);              // 转90度
    return true;                 // 继续巡线
}

// 示例3: 完成3圈后停车
uint16_t lapCount = 0;
bool CrossroadHandler() {
    lapCount++;
    if (lapCount >= 3) {
        return false;  // 停车
    }
    driveTrain.drive(40, 40);
    HAL_Delay(300);
    return true;
}
```

---

## 🔄 完整流程图

### 巡线主循环流程

```
开始
  │
  ▼
┌──────────────────┐
│ 读取8路ADC值      │ ← DMA自动采样
└────┬─────────────┘
     │
     ▼
┌──────────────────┐
│ 阈值二值化        │ → 黑/白判断
└────┬─────────────┘
     │
     ▼
┌──────────────────┐
│ 统计黑线数量      │
└────┬─────────────┘
     │
     ├─ ≥6个 ────→ 十字路口处理 → 返回
     │
     ▼
┌──────────────────┐
│ 计算位置(加权平均)│
└────┬─────────────┘
     │
     ├─ INT16_MIN ─→ 丢线处理 → 搜索
     │
     ▼
┌──────────────────┐
│ 计算偏差(error)  │ = position - 0
└────┬─────────────┘
     │
     ▼
┌──────────────────┐
│ PID计算          │ = P + I + D
└────┬─────────────┘
     │
     ▼
┌──────────────────┐
│ 输出限幅         │ (-100 ~ +100)
└────┬─────────────┘
     │
     ▼
┌──────────────────┐
│ 差速控制         │
│ 左速 = 基速 - PID │
│ 右速 = 基速 + PID │
└────┬─────────────┘
     │
     ▼
┌──────────────────┐
│ 驱动电机         │
└────┬─────────────┘
     │
     ▼
  延时20ms (50Hz)
     │
     └──→ 返回开始
```

---

## 📊 数据流详解

### 完整数据流

```
物理世界                  数字世界                    控制输出
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

黑色线条                  ADC采样
  ↓                         ↓
红外反射          rawValues[8] = {3800,3850,...}
  ↓                         ↓
光敏管导通              阈值判断
  ↓                         ↓
电压变化            isBlack[8] = {1,1,1,0,...}
  ↓                         ↓
ADC转换               位置计算
  ↓                         ↓
数字量              position = -300
  ↓                         ↓
                       PID计算
                          ↓
                     output = 30
                          ↓
                      差速控制
                          ↓
                  左轮=20, 右轮=80
                          ↓
                       驱动电机
                          ↓
                      小车右转 ↷
                          ↓
                     重新对准线条 ✅
```

---

## 🎯 我们的项目实现了哪些功能

### ✅ 已实现的检测和处理

| 功能 | 实现方式 | 作用 |
|------|---------|------|
| **ADC采样** | 8通道DMA连续采样 | 实时获取传感器数据 |
| **黑白判断** | 阈值二值化 | 将模拟信号转为数字信号 |
| **位置计算** | 加权平均法 | 精确定位线条位置 |
| **在线检测** | 遍历检查 | 判断是否检测到线 |
| **丢线检测** | 全白判断 | 识别丢线状态 |
| **十字路口检测** | 黑线数量统计 | 识别特殊路况 |
| **PID控制** | 比例-积分-微分 | 平滑跟线 |
| **差速转向** | 左右轮速差 | 实现转向 |
| **丢线搜索** | 智能转向搜索 | 自动恢复巡线 |
| **十字路口处理** | 用户回调 | 灵活处理路口 |
| **自动校准** | 白色/黑色采样 | 自适应环境 |
| **速度控制** | 可调基础速度 | 适应不同场景 |
| **输出限幅** | 防止过度修正 | 稳定控制 |
| **积分饱和保护** | 限制积分项 | 防止超调 |

---

## 📈 性能参数

| 参数 | 值 | 说明 |
|------|-----|------|
| 控制频率 | 50Hz (20ms) | 主循环周期 |
| ADC采样时间 | ~45μs | 8通道总时间 |
| 位置精度 | ±150 | 满量程2000 |
| 响应时间 | <20ms | 从检测到执行 |
| 最大速度 | 100% | 可调节 |
| PID输出范围 | ±100 | 限幅保护 |

---

## 🎓 总结

### 核心算法链

```
传感器采样 → 二值化 → 位置计算 → PID控制 → 差速驱动
```

### 关键技术点

1. **加权平均法** - 将多传感器数据融合为单一位置值
2. **PID控制** - 平滑、精准的跟线控制
3. **差速转向** - 通过速度差实现转向
4. **智能搜索** - 丢线后根据历史位置搜索
5. **状态检测** - 识别多种路况（在线/丢线/十字路口）

### 优势

- ✅ 实时性强（50Hz控制频率）
- ✅ 鲁棒性好（丢线搜索、十字路口处理）
- ✅ 可调性强（PID参数、速度可调）
- ✅ 可扩展性好（用户回调、状态监控）

---

**现在你应该完全理解巡线算法的工作原理了！** 🎉

如有疑问欢迎随时提问！