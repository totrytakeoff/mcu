# 传感器校准归一化 - 解决位置偏差的关键

## 问题背景

### 发现的问题
在使用抛物线拟合法进行巡线时，发现位置检测存在系统性偏差：
- **负向位置**：可以达到 -1000（左边缘）
- **正向位置**：只能达到 +800 左右（右边缘）
- **中心点偏移**：偏离真实中心约半个传感器的距离

### 根本原因
**传感器2存在硬件差异**，之前使用固定偏移补偿（+120）来修正：
```cpp
// ❌ 错误的补偿方式
int16_t sensor_offset[8] = {0, 120, 0, 0, 0, 0, 0, 0};
```

**问题**：传感器的响应是非线性的
- 在**高亮度区域**（白色校准值附近）：传感器2与其他传感器相差 ~120
- 在**低亮度区域**（黑色校准值附近）：传感器2与其他传感器相差 ~几十

固定偏移无法同时补偿不同亮度下的差异，导致：
1. 白线在左侧时，拟合偏差较小
2. 白线在右侧时，拟合偏差较大
3. 整体位置向一侧偏移

---

## 解决方案：校准归一化

### 核心思想
不使用原始ADC值进行拟合，而是使用**归一化后的比例值**（0.0~1.0）：

```
normalized = (raw - black) / (white - black)
```

其中：
- `raw`：当前传感器读数
- `black`：该传感器的黑色校准值
- `white`：该传感器的白色校准值

### 优势
1. **消除硬件差异**：每个传感器都按照自己的校准范围归一化
2. **线性化响应**：0.0表示纯黑，1.0表示纯白，中间值线性插值
3. **提高精度**：抛物线拟合基于统一的0~1范围，不受硬件差异影响

---

## 实现细节

### 修改前：直接使用原始值
```cpp
float LineFollower::calculateLinePositionParabolic(uint16_t sensor_data[8]) {
    // 1. 数据预处理（根据线模式）
    float values[8];
    
    if (line_mode_ == LineMode::WHITE_LINE_ON_BLACK) {
        // 黑底白线：反转数值（让白线变成峰值）
        for (int i = 0; i < 8; i++) {
            values[i] = ADC_MAX - sensor_data[i];  // ❌ 使用原始ADC值
        }
    }
    // ...
}
```

### 修改后：校准归一化
```cpp
float LineFollower::calculateLinePositionParabolic(uint16_t sensor_data[8]) {
    // 1. 获取校准数据
    uint16_t white_cal[8];
    uint16_t black_cal[8];
    sensor_.getCalibrationValues(white_cal, black_cal);
    
    // 2. 数据预处理：归一化 + 根据线模式处理
    float values[8];
    
    for (int i = 0; i < 8; i++) {
        // 归一化到 0.0~1.0
        float range = (float)(white_cal[i] - black_cal[i]);
        float normalized;
        
        if (range > 1.0f) {
            // 正常校准范围
            normalized = (float)(sensor_data[i] - black_cal[i]) / range;
            // 限幅到 [0, 1]
            if (normalized < 0.0f) normalized = 0.0f;
            if (normalized > 1.0f) normalized = 1.0f;
        } else {
            // 校准数据无效，退化为原始值归一化
            normalized = (float)sensor_data[i] / ADC_MAX;
        }
        
        if (line_mode_ == LineMode::WHITE_LINE_ON_BLACK) {
            // 黑底白线：反转比例值（让白线变成峰值）
            values[i] = 1.0f - normalized;  // ✅ 使用归一化值
        } else {
            // 白底黑线：直接使用归一化值
            values[i] = normalized;
        }
    }
    
    // 3. 使用归一化值进行抛物线拟合
    // ...
}
```

---

## 效果对比

### 修改前
```
Pos:-1000  （左侧极限）
Pos:-500
Pos:0
Pos:+500
Pos:+800   （右侧极限，无法到达+1000）
```
- 范围不对称：-1000 到 +800
- 中心点偏移：约 -100

### 修改后（预期）
```
Pos:-1000  （左侧极限）
Pos:-500
Pos:0      （真实中心）
Pos:+500
Pos:+1000  （右侧极限）
```
- 范围对称：-1000 到 +1000
- 中心点准确：0

---

## 参数调整

### 使用归一化后，PID参数需要调整

**原因**：
- 原始ADC值范围：0~4095（较大）
- 归一化值范围：0.0~1.0（较小）
- 拟合结果更线性、更稳定

**推荐参数**（已更新到 `main.cpp`）：
```cpp
// 基础配置
line_follower.setPID(0.10f, 0.0f, 1.2f);  // Kp降低，Kd微调
line_follower.setSpeed(15);               // 基础速度

// 动态缩放配置
line_follower.setDynamicScaleRange(0.03f, 0.18f);  // 恢复合理范围
line_follower.setScaleCurve(LineFollower::ScaleCurve::LINEAR);  // 线性曲线
```

---

## 重要提示

### 1. 必须先校准
归一化依赖于校准数据，使用前必须：
- 长按PD2按钮3秒进入校准模式
- 校准白色底板
- 校准黑色底板
- 校准数据自动保存到EEPROM

### 2. 传感器偏移补偿可以移除
现在已经不需要手动偏移补偿了：
```cpp
// ❌ 不再需要
int16_t sensor_offset[8] = {0, 120, 0, 0, 0, 0, 0, 0};

// ✅ 使用零偏移
int16_t sensor_offset[8] = {0, 0, 0, 0, 0, 0, 0, 0};
```

### 3. 校准数据无效时的退化处理
如果校准范围 `(white - black) ≤ 1`，算法会自动退化为原始值归一化：
```cpp
normalized = (float)sensor_data[i] / ADC_MAX;
```

---

## 技术要点

### 为什么归一化能消除传感器差异？

**示例**：
- 传感器1：黑色=200, 白色=2000, 范围=1800
- 传感器2：黑色=300, 白色=2120, 范围=1820

当白线照射时：
- 传感器1读数：1800 → 归一化：(1800-200)/1800 = 0.89
- 传感器2读数：1920 → 归一化：(1920-300)/1820 = 0.89

**结果**：尽管原始值相差120，但归一化后完全一致！

### 抛物线拟合的输入
拟合使用的是 `values[i]`（0.0~1.0），而不是 `sensor_data[i]`（0~4095）：
- 更小的数值范围，浮点运算更稳定
- 所有传感器在同一尺度下，拟合更准确
- 峰值检测更可靠

---

## 总结

| 项目 | 修改前 | 修改后 |
|------|--------|--------|
| 拟合输入 | 原始ADC值 | 校准归一化值 |
| 传感器差异 | 固定偏移补偿（不准确） | 自动归一化（准确） |
| 位置范围 | -1000 到 +800（不对称） | -1000 到 +1000（对称） |
| 中心点偏移 | ~-100 | 0（准确） |
| PID调参 | 需要补偿硬件差异 | 基于真实物理位置 |

**关键改进**：从"手动补偿硬件差异"转变为"自动消除硬件差异"，大幅提升了位置检测的精度和可靠性。
